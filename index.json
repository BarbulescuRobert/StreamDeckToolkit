{
  "articles/install.html": {
    "href": "articles/install.html",
    "title": "Install Project Template | StreamDeckToolkit",
    "keywords": "Install Project Template From File System Installing the template from your filesystem is useful for local testing of the template itself. If you are actively working on the template making changes, this is the route you need to use. To install, run the following command from the root of the repository. dotnet new install StreamDeckPluginTemplate To pick up any changes you have made to the template source, you must uninstall the template and reinstall it. To uninstall, run the following command from the root of the respository. Windows: dotnet new uninstall StreamDeckPluginTemplate OSX/Linux: dotnet new -u $PWD/Templates/StreamDeck.PluginTemplate.Csharp From NuGet dotnet new -i StreamDeckPluginTemplate OR - Install-Package StreamDeckPluginTemplate [-Version x.y.zzz]"
  },
  "articles/projects/dashboard.html": {
    "href": "articles/projects/dashboard.html",
    "title": "StreamDeck Dashboard | StreamDeckToolkit",
    "keywords": "StreamDeck Dashboard A collection of stream deck actions in a single plugin for developers code"
  },
  "articles/contributing.html": {
    "href": "articles/contributing.html",
    "title": "Contributing | StreamDeckToolkit",
    "keywords": "Contributing There are two ways to contribute to this repo, either the code or the docs. First check for any open Issues on GitHub then comment to indicate you're helping out, or raise a new one with details. Code Pull the code and add your necessary changes, then PR back to dev for review. Docs You're in them! To help out fork this repo, install DocFX and update/add any info. docfx docfx.json will build the site, then move to the \"_site\" folder and run docfx serve then open a browser to \"http://localhost:8080/\" to see your updates. There are the Articles you can write to explain the toolkit, then the API docs which builds from the src. The docfx.json file contains a metadata which points to the src to built to produce { \"metadata\": [ { \"src\": [ { \"files\": [\"**.csproj\"], \"src\": \"../src\" } ], \"dest\": \"api\" } ] } Template This documentation site is using the DocFX Material template . The docfx.json file contains a template that has been updated, alongside the templates folder containing the src of the template. \"template\": [ \"default\", \"templates/material\" ]"
  },
  "articles/plugins.html": {
    "href": "articles/plugins.html",
    "title": "Plugins | StreamDeckToolkit",
    "keywords": "Plugins Please add your plugins to the list: vscode-streamdeck streamdeck-plugins https://streamdeck-plugins.com/ WayBack Machine version BarRaider"
  },
  "articles/template/action.html": {
    "href": "articles/template/action.html",
    "title": "Action | StreamDeckToolkit",
    "keywords": "Action When you use the template there are a number of parameters which can set things in the following Action class: --uuid com.yourcompany.pluginname.actionname --plugin-name FirstPlugin You will also have a model created CounterSettingsModel which will be set. Attribute [ActionUuid(Uuid=\"com.yourcompany.pluginname.actionname\")] Class Name The --plugin-name will be a prefix for the Action class that is created: public class FirstPluginAction : BaseStreamDeckActionWithSettingsModel<Models.CounterSettingsModel> BaseStreamDeckAction public ILogger Logger { get; } public string ActionUuid { get; } protected internal ConnectionManager Manager { get; set; } There are a number of methods you can then override and implement with your own logic: public virtual Task OnApplicationDidLaunch(StreamDeckEventPayload args); public virtual Task OnApplicationDidTerminate(StreamDeckEventPayload args); public virtual Task OnDeviceDidConnect(StreamDeckEventPayload args); public virtual Task OnDeviceDidDisconnect(StreamDeckEventPayload args); public virtual Task OnDidReceiveGlobalSettings(StreamDeckEventPayload args); public virtual Task OnDidReceiveSettings(StreamDeckEventPayload args); public virtual Task OnKeyDown(StreamDeckEventPayload args); public virtual Task OnKeyUp(StreamDeckEventPayload args); public virtual Task OnPropertyInspectorDidAppear(StreamDeckEventPayload args); public virtual Task OnPropertyInspectorDidDisappear(StreamDeckEventPayload args); public virtual Task OnTitleParametersDidChange(StreamDeckEventPayload args); public virtual Task OnWillAppear(StreamDeckEventPayload args); public virtual Task OnWillDisappear(StreamDeckEventPayload args); Just call the base method then implement the functionality you wish to achieve. For example: public override async Task OnDidReceiveSettings(StreamDeckEventPayload args) { await base.OnDidReceiveSettings(args); await Manager.SetTitleAsync(args.context, SettingsModel.Counter.ToString()); } public override async Task OnWillAppear(StreamDeckEventPayload args) { await base.OnWillAppear(args); await Manager.SetTitleAsync(args.context, SettingsModel.Counter.ToString()); } BaseStreamDeckActionWithSettingsModel public T SettingsModel { get; } public override Task OnDidReceiveSettings(StreamDeckEventPayload args); public override Task OnWillAppear(StreamDeckEventPayload args); protected void SetModelProperties(StreamDeckEventPayload args);"
  },
  "articles/projects/emulator.html": {
    "href": "articles/projects/emulator.html",
    "title": "Stream Deck Emulator | StreamDeckToolkit",
    "keywords": "Stream Deck Emulator A simple emulator for the Stream Deck Application to allow plugin developers to develop, test, and debug their plugins without requiring a physical Stream Deck device. See the code . <!-- Reference Links -->"
  },
  "articles/pre-reqs.html": {
    "href": "articles/pre-reqs.html",
    "title": "Pre-Requisites | StreamDeckToolkit",
    "keywords": "Pre-Requisites In order to make use of this template, you will need to have the Dotnet Core SDK (version 2.2.100 or above) installed on your development machine. While not absolutely necessary, it is strongly recommended to have the Stream Deck Software installed, to be able to perform some integration testing of your plugin. <!-- Reference Links -->"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentaion | StreamDeckToolkit",
    "keywords": "API Documentaion Welcome to the API Documentation, please see the navigation for each of the project apis in \"StreamDeck Toolkit\"."
  },
  "articles/create.html": {
    "href": "articles/create.html",
    "title": "Creating a Plugin Action | StreamDeckToolkit",
    "keywords": "Creating a Plugin Action The Stream Deck Toolkit provides the functionality that communicates directly with the Stream Deck software. When creating a plugin, you are responsible for creating actions for the Stream Deck buttons to perform. There are two base classes that you can inherit from when creating your action: BaseStreamDeckAction - this class contains all the integrations necessary to communicate with the Stream Deck at the 'barebones' level. Inheriting from this class will give you the greatest control over how your action sends and receives data from the software. BaseStreamDeckActionWithSettingsModel<T> - this class inherits from BaseStreamDeckAction, this class will automate the population of model properties, where type T is defined as the data that is stored when issuing a 'setSettings' event to the Stream Deck software. The property SettingsModel will automatically instantiate an instance of class T, so it is best to assign default values when defining your class T. Also, when using the Property Inspector and passing data back and forth, ensure that the properties defined in the settingsModel in JavaScript matches those that you have defined in T for the automatic mapping to occur between both environments. Your project may contain any number of actions, inheriting from one of the classes above. In order for the Action to be automatically registered on start up, it must bear the [ActionUuid(Uuid=\"com.fritzanfriends.pluginname.anotheraction\")] attribute. Actions must also be manually registered in the manifest.json file, with the Uuid that matches ActionUuid attribute."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Welcome | StreamDeckToolkit",
    "keywords": "Welcome Welcome to the documentation for the StreamDeck Toolkit, a .NET Standard library, template, and tools for building extensions to the Elgato Stream Deck. What Is This? This is a template to help create plugins for the Elgato Stream Deck , using the Stream Deck SDK with Dotnet Core . <!-- Reference Links -->"
  },
  "articles/streams.html": {
    "href": "articles/streams.html",
    "title": "Streams | StreamDeckToolkit",
    "keywords": "Streams You can find all the Twitch streams that built this toolkit on YouTube StreamDeck Toolkit Playlist"
  },
  "articles/using.html": {
    "href": "articles/using.html",
    "title": "Using the Template | StreamDeckToolkit",
    "keywords": "Using the Template Once the template is installed, open a terminal in the folder of your choice and create a new project. dotnet new streamdeck-plugin --plugin-name FirstPlugin --uuid com.yourcompany.pluginname.actionname --skipRestore false Or create a directory in a location of your choice, change to that directory and run the command, which will inherit the directory name as the project name with default values. dotnet new streamdeck-plugin"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | StreamDeckToolkit",
    "keywords": "Welcome Welcome to the documentation for the StreamDeck Toolkit, a .NET Standard library, template, and tools for building extensions to the Elgato Stream Deck. What Is This? This is a template to help create plugins for the Elgato Stream Deck , using the Stream Deck SDK with Dotnet Core . Check out the Articles section for how to work with the Toolkit, and the API section to see the code. <!-- Reference Links -->"
  },
  "articles/template/template.html": {
    "href": "articles/template/template.html",
    "title": "Working With This Template | StreamDeckToolkit",
    "keywords": "Working With This Template Welcome Congratulations! You've just taken the first major step in writing a custom plugin for the Elgato Stream Deck . State of Things Within the directory from which you are reading this file, there exist a few other necessary files. These are: _StreamDeckPlugin_.csproj : The C# project file used to build the plugin Program.cs : The code for the application which will be called by the Stream Deck software when loading and running your plugin. DefaultPluginAction.cs : The file in which the functionality of the first (default) action for the plugin will be written. This file provides a basic implementation of an action for your plugin, following a pattern which can be repeated. What's Next? First, a Word of Caution Due to the multi-platform target of the Stream Deck , when specifying filesystem paths which will be used at runtime (images, other assets), use the POSIX/Unix standard forward slash ( / ) as the directory separator. Do this path/to/my/assets Instead of path\\to\\my\\assets The manifest.json file The manifest.json file (also referred to as the manifest or manifest file ) is the mechanism used by the Stream Deck SDK to uniquely identify plugins, their actions and other parameters. Your first step should set a value for both the Author and the URL values, representing you and your plugin. Images and Other Assets The following are the base set of images/icons which are needed for the plugin. While defaults have been provided, they should be changed to help distinguish your plugin and its action(s) from others. Unless otherwise noted, image assets should all be in the \"Portable Network Graphics\" (PNG) format. Note While all efforts have been made to ensure the correctness of this information, please refer to the official Style Guide and Manifest file definition for the latest and most up-to-date information. Category Icon ( a.k.a. Plugin Icon ) Path to property in manifest.json file: Icon Purpose The category icon, identified by the Icon property in the manifest , is the primary visual identifier for your plugin. It is also used to display information about your plugin in the More Actions... list, which displays the list of available plugins to download to uses, as well as the category (group) icon in the Actions list if your plugin supports more than a single action. Specifications The Icon property in the manifest represents the base file name of the image, without a file extension. For example, if your icon's file name is myPluginIcon.png , you would set the value as myPluginIcon . There are two of these files necessary. A default one for a regular, non-scaled (high-DPI) display, and another for scaled display. The default icon should be 28 pixels squared (28x28px), and named with the base file name and extension. i.e. _PluginName_.png . The other file, for high-DPI displayes, must be 56 pixels squared (56x56px), and the value @2x appended to the file name, before the extension. i.e. _PluginName_@2x.png Action Image (Icon) Path to property in manifest.json file: Actions[x].Icon Purpose The action image, for which there is one for each action available from the plugin, is the icon which helps identify the action item in the Actions list, within the category (group) defined by your plugin. Just as with the Category Icon , when setting its value in the manifest , do not specify an extension. Specifications Each element in the Actions element of the manifest has an Icon property which must be set (which one possible exception - see below). While not strictly necessary, each action should have its own, distinct icon for its visual identity. Per the current specifications, the Action Image should be a single color - #d8d8d8 ( rgb(216,216,216) ). Again, just as with the Category Icon , two separate copies of this file are needed, with the same naming rules but different sizes; a default one for a regular, non-scaled (high-DPI) display, and another for scaled display. The default icon should be 20 pixels squared (20x20px), and preferably named in a manner in which it can be easily related to its action, such as actionIcon.png . When setting its value in the manifest , here too specify only the file name, and do not include the etension. The other file, for high-DPI displayes, must be 40 pixels squared (40x40px), and the value @2x appended to the file name, before the extension. i.e. actionIcon@2x.png Exceptions An Action item is not required to have an icon specified (but still can) if its VisibleInActionList property in the manifest is set to false . Key Icon Path to property in manifest.json file: Actions[x].States[y].Image Purpose The Key Icon is the icon which is displayed on the key(s) to which is is assigned on the Stream Deck , as well as within the Stream Deck software during configuration. If your action supports multiple states, the Key Icon will be displayed when its assigned state is active. Each action hast as least one state, and as of this time, has at most two states. Once again, just as with the Category Icon and Action Image , when setting its value in the manifest , do not specify an extension. Specifications Again, just as with the Category Icon and the Action Image ,two separate copies of this file are needed, with the same naming rules but different sizes; a default one for a regular, non-scaled (high-DPI) display, and another for scaled display. The default icon should be 72 pixels squared (72x72px). Again, it should preferably named in a manner in which it can be easily related to either the action or state is represents, such as actionIconButton.png or actionIconActive.png . Can I do any more? Of course! First, congratulations on getting your first action for your Stream Deck plugin working! To allow your plugin to do more, you will need to create (and implement) a new Action definition. Here is how you do this: Create a new class (in a new file or an existing one), and make sure it inherits from the BaseStreamDeckAction class e.g.: internal class MyNextPluginAction : BaseStreamDeckAction Implement the required properties and methods, such as UUID Register it with the ConnectionManager instance within the Program.cs file. Look for the .RegisterAction(new DefaultPluginAction() code line, copy it, and change the type DefaultPluginAction to your new class' name. From the example in step 1, this would look like .RegisterAction(new MyNextPluginAction()) . Add a definition for the new action in the manifest.json file, ensuring that the value for the UUID field in the manifest matches the UUID property of your new class. That's it! Repeat this process for any additional actions you wish to include and perform as part of your plugin. References Here are some helpful references for both this template and the Stream Deck: Plugin Homepage Stream Deck Page Stream Deck SDK Documentation <!-- References -->"
  },
  "articles/template/propertyinspector.html": {
    "href": "articles/template/propertyinspector.html",
    "title": "Property Inspector | StreamDeckToolkit",
    "keywords": "Property Inspector There are various types of fields that are supported in property inspector see Elgato Github PiSamples and Elgato SDK Documentation The above sample from GitHub allows you to drag and drop elements into your html for quick development. Add it to the property_inspector.html file in the project."
  }
}